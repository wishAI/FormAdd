// Generated by CoffeeScript 1.11.1
(function() {
  var WebPDecodeAndDraw, convertBinaryToArray, convertResponseBodyToText, loadFile;

  window.atTest = (function() {
    function atTest() {}

    atTest.prototype.zhazha = 123;

    atTest.prototype.setup = function() {
      return this.showText();
    };

    atTest.prototype.showText = function() {
      var _self, yiyi;
      this.kela = 90;
      _self = this;
      yiyi = 60;
      return $("#myCanvas").on("click", function() {
        return $("#myCanvas").each(function() {
          return alert(yiyi);
        });
      });
    };

    return atTest;

  })();

  $(document).ready(function() {
    var test;
    test = new atTest();
    return test.setup();
  });


  /*pointerMove = (evt)->
    null
   */

  WebPDecodeAndDraw = function(data) {
    var WebPImage, biHeight, biWidth, bitStream, bitmap, canvas, config, context, decoder, h, k, l, mode, ok, output, outputData, output_buffer, ref, ref1, status, statusCode, w;
    canvas = document.getElementById("myCanvas");
    WebPImage = {
      width: {
        value: 0
      },
      height: {
        value: 0
      }
    };
    decoder = new WebPDecoder();
    data = convertBinaryToArray(data);
    config = decoder.WebPDecoderConfig;
    output_buffer = config.j;
    bitStream = config.input;
    if (!decoder.WebPInitDecoderConfig(config)) {
      return false;
    }
    statusCode = decoder.VP8StatusCode;
    status = decoder.WebPGetFeatures(data, data.length, bitStream);
    if (status !== 0) {
      console.log('status error');
    }
    mode = decoder.WEBP_CSP_MODE;
    output_buffer.J = 4;
    status = decoder.WebPDecode(data, data.length, config);
    ok = status === 0;
    if (!ok) {
      console.log("Decoding of %s failed.\n");
      return false;
    }
    bitmap = output_buffer.c.RGBA.ma;
    if (bitmap) {
      biHeight = output_buffer.height;
      biWidth = output_buffer.width;
      canvas.height = biHeight;
      canvas.width = biWidth;
      context = canvas.getContext('2d');
      output = context.createImageData(canvas.width, canvas.height);
      outputData = output.data;
      for (h = k = 0, ref = biHeight; 0 <= ref ? k < ref : k > ref; h = 0 <= ref ? ++k : --k) {
        for (w = l = 0, ref1 = biWidth; 0 <= ref1 ? l < ref1 : l > ref1; w = 0 <= ref1 ? ++l : --l) {
          outputData[0 + w * 4 + (biWidth * 4) * h] = bitmap[1 + w * 4 + (biWidth * 4) * h];
          outputData[1 + w * 4 + (biWidth * 4) * h] = bitmap[2 + w * 4 + (biWidth * 4) * h];
          outputData[2 + w * 4 + (biWidth * 4) * h] = bitmap[3 + w * 4 + (biWidth * 4) * h];
          outputData[3 + w * 4 + (biWidth * 4) * h] = bitmap[0 + w * 4 + (biWidth * 4) * h];
        }
      }
      return context.putImageData(output, 0, 0);
    }
  };

  loadFile = function(type) {
    var http;
    if (!type) {
      type = 'dec';
    }
    http = new XMLHttpRequest();
    if (type === 'dec') {
      http.open('get', '1.webp');
      if (http.overrideMimeType) {
        http.overrideMimeType('text/plain; charset=x-user-defined');
      } else {
        http.setRequestHeader('Accept-Charset', 'x-user-defined');
      }
      http.onreadystatechange = function() {
        var response;
        if (http.readyState === 4) {
          if (!http.responseBody) {
            response = http.responseText.split('').map(function(e) {
              return String.fromCharCode(e.charCodeAt(0) & 0xff);
            }).join('');
          } else {
            response = convertResponseBodyToText(http.responseBody);
          }
          if (type === 'dec') {
            return WebPDecodeAndDraw(response);
          }
        }
      };
      return http.send(null);
    } else if (type === 'enc') {
      return ImageToCanvas('/images-enc/1.webp');
    }
  };

  convertResponseBodyToText = function(IEByteArray) {
    var ByteMapping, i, j, k, l, lastChr, rawBytes;
    ByteMapping = {};
    for (i = k = 0; k < 256; i = ++k) {
      for (j = l = 0; l < 256; j = ++l) {
        ByteMapping[String.fromCharCode(i + j * 256)] = String.fromCharCode(i) + String.fromCharCode(j);
      }
    }
    rawBytes = IEBinaryToArray_ByteStr(IEByteArray);
    lastChr = IEBinaryToArray_ByteStr_Last(IEByteArray);
    return rawBytes.replace(/[\s\S]/g, function(match) {
      return ByteMapping[match];
    }) + lastChr;
  };

  convertBinaryToArray = function(binary) {
    var arr, i, k, num, ref;
    arr = new Array();
    num = binary.length;
    for (i = k = 0, ref = num; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      arr.push(binary.charCodeAt(i));
    }
    return arr;
  };

}).call(this);

//# sourceMappingURL=test.js.map
